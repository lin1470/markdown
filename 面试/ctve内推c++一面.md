

[TOC]

电话面试

## 面试内容

### 项目经验

这个是一定要讲的，要多啰嗦讲多啰嗦，反正，他也不会真的在乎，我就感觉，有的你就讲多点，这样的话，他有可能会从中讲他感兴趣的话题，然后发问你，还是讲多点，这样他会觉得你是在简历上面写的东西是有真材实料的。

还有你在简历上面写的东西都会涉及到一些，这个是自然的，没有什么大问题。

## c++基础

这个真的是基础中的基础

### c++的多态的实现原理

这个就会涉及到虚指针和虚函数表，这个知识点我自己觉得掌握得不够透彻，不过的话，我觉得这个话题本身就是比较深入的内容，只要你对这方面有个大概的感性的认识，你要能够讲就可以的了。所以之后的话，这一方面要加深

### c++的智能指针

这个话题是比较常见的，这个他没有继续深入问进去，就是谈了一下我对智能指针的了解。这里我谈的大概就是普通智能指针的简单实现原理而已，其中其他的比如说auto,share,uque都没有涉及，其实这些的话是个很深的问题，这个要加深

## 操作系统

### 进程通信

进程之间的通信，这个嘛，原本有五中进程之间的通信的。

1. 管道
2. 信号量（这个非常的后悔，当时犹豫了，其实信号量就是平时我们操作系统的那个，通过它来控制共享变量区的，好蠢）
3. FIFO（这个他深入问了与管道的区别，管道的话就是有血缘关系的进程可以进行通信，而FIFO的话，就是没有血缘关系的进程都可以进行通信的）
4. 内存映射共享
5. **消息队列**（这个没有回答上来）

### 对比了FIFO和管道的区别

## 算法知识

### 简述二分查找算法，

#### 当使用递归来实现的时候，这个结束条件是什么？？

找到或者没有找到两种情况，找到就是输入的start>end然后结束递归

#### 数组过大时使用递归来实现又会咋样，我的回答是栈溢出，不知道对不对捏

### 简述用两个栈来实现一个队列的算法（思考一下）

网上的答案

> 栈的特性是先进后出（FILO）,队列的特性是先进先出（FIFO）,在实现delete时，我们的难点是如何将栈中最底层的数据拿出来，我们有两个栈，所以我们可以将一个栈中的数据依次拿出来压入到另一个为空的栈，另一个栈中数据的顺序恰好是先压入栈1的元素此时在栈2的上面，为了实现效率的提升，我们在delete时，判断栈2是否有数据，如果有的话，直接删除栈顶元素，在栈2为空时才将栈1的数据压入到栈2中，从而提高程序的运行效率，实现过程可以分为下面几个步骤： 
> 1、push操作时，一直将数据压入到栈2中 
> 2、delete操作时，首先判断栈2是否为空，不为空的情况直接删除栈2栈顶元素，为空的话将栈1的数据压入到栈2中，再将栈2栈顶元素删除。 

感觉也是送分题，不过当一开始没有思路而已，后来我也是按照上面的流程说了一遍，问题不打，下一个

### 大端和小端，如果判断你是大端存储还是小端存储

这个是真的猛，幸好是在计算机网络中看到这么一个知识点。



直接上代码吧：

```c
#include<stdio.h>

int main(int argc, char** argv){

	//联合（union）中，所有成员引用的是内存中相同位置，
	//由具体成员类型决定了这些位如何被解释
	union{
		short s;
		char c[sizeof(short)];
	} un;

	un.s = 0x0102; //16进制数中，02是低序字节，01是高序字节

	if(sizeof(short)==2){
		if(un.c[0]==1 && un.c[1]==2){
			printf("big-endian\n");
		}else if(un.c[0]==2 && un.c[1]==1){
			printf("little-endian\n");
		}else{
			printf("unknow\n");
		}
	}else{
		printf("sizeof(short) = %d\n",sizeof(short));
	}

	return 0;
}

```

> 这里注意sizeof(short)是2，因为是2个字节，所以char[0]和char[1]两个，但是呢，这个union啊，变量之间的内存又是共用的，所以呢。我们存un.s的时候，实际上通过un.c来访问的也是同样的地址，相同的内容，看懂代码就问题不大。

这里还有个知识点需要注意，就是网络协议规定，网络传输用的大端的存储。

而我们电脑有些的是大端有些是小端，这个需要注意的。



## 计算机网络的知识

### tcp和udp的区别

最大的区别就是一个是tcp是面向链接，udp是面向无链接服务的

### 还有其他的区别呢

有呀，比如说tcp有流量控制，拥塞控制，还有建立的过程，他们数据文本的不一样，还有确认重传机制

#### 最后一个问题，传输层的上面的应用，怎么区分哪个数据包，

这个直接投降。